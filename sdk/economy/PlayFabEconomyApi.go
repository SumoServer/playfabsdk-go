package economy

// This code was generated by a tool. Any changes may be overwritten

import (
    "encoding/json"

    playfab "github.com/dgkanatsios/playfabsdk-go/sdk"

    "github.com/mitchellh/mapstructure"
)

// AddVirtualCurrencies increase virtual currencies amount.
// https://api.playfab.com/Documentation/Economy/method/AddVirtualCurrencies
func AddVirtualCurrencies(settings *playfab.Settings, postData *AddVirtualCurrenciesRequestModel, entityToken string) (*AddVirtualCurrenciesResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Inventory/AddVirtualCurrencies", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &AddVirtualCurrenciesResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// ConsumeInventoryItems consume inventory items.
// https://api.playfab.com/Documentation/Economy/method/ConsumeInventoryItems
func ConsumeInventoryItems(settings *playfab.Settings, postData *ConsumeInventoryItemsRequestModel, entityToken string) (*ConsumeInventoryItemsResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Inventory/ConsumeInventoryItems", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &ConsumeInventoryItemsResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// CreateBundle create a bundle
// https://api.playfab.com/Documentation/Economy/method/CreateBundle
func CreateBundle(settings *playfab.Settings, postData *CreateBundleRequestModel, entityToken string) (*CreateBundleResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Catalog/CreateBundle", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &CreateBundleResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// CreateCurrency create a currency
// https://api.playfab.com/Documentation/Economy/method/CreateCurrency
func CreateCurrency(settings *playfab.Settings, postData *CreateCurrencyRequestModel, entityToken string) (*CreateCurrencyResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Catalog/CreateCurrency", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &CreateCurrencyResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// CreateDraftItem creates a new item in the working catalog using provided metadata.
// https://api.playfab.com/Documentation/Economy/method/CreateDraftItem
func CreateDraftItem(settings *playfab.Settings, postData *CreateDraftItemRequestModel, entityToken string) (*CreateDraftItemResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Catalog/CreateDraftItem", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &CreateDraftItemResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// CreateDraftUgcItem creates a new community catalog item in the working catalog using provided metadata.
// https://api.playfab.com/Documentation/Economy/method/CreateDraftUgcItem
func CreateDraftUgcItem(settings *playfab.Settings, postData *CreateDraftItemRequestModel, entityToken string) (*CreateDraftItemResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/UserGeneratedContent/CreateDraftUgcItem", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &CreateDraftItemResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// CreateOrUpdateReview creates or updates a review for the specified item.
// https://api.playfab.com/Documentation/Economy/method/CreateOrUpdateReview
func CreateOrUpdateReview(settings *playfab.Settings, postData *CreateOrUpdateReviewRequestModel, entityToken string) (*CreateOrUpdateReviewResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Catalog/CreateOrUpdateReview", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &CreateOrUpdateReviewResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// CreateStore create a store
// https://api.playfab.com/Documentation/Economy/method/CreateStore
func CreateStore(settings *playfab.Settings, postData *CreateStoreRequestModel, entityToken string) (*CreateStoreResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Catalog/CreateStore", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &CreateStoreResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// CreateSubscription create a subscription
// https://api.playfab.com/Documentation/Economy/method/CreateSubscription
func CreateSubscription(settings *playfab.Settings, postData *CreateSubscriptionRequestModel, entityToken string) (*CreateSubscriptionResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Catalog/CreateSubscription", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &CreateSubscriptionResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// CreateUgcUploadUrls creates one or more upload URLs which can be used by the client to upload raw mod file data.
// https://api.playfab.com/Documentation/Economy/method/CreateUgcUploadUrls
func CreateUgcUploadUrls(settings *playfab.Settings, postData *CreateUploadUrlsRequestModel, entityToken string) (*CreateUploadUrlsResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/UserGeneratedContent/CreateUgcUploadUrls", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &CreateUploadUrlsResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// CreateUploadUrls creates one or more upload URLs which can be used by the client to upload raw file data.
// https://api.playfab.com/Documentation/Economy/method/CreateUploadUrls
func CreateUploadUrls(settings *playfab.Settings, postData *CreateUploadUrlsRequestModel, entityToken string) (*CreateUploadUrlsResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Catalog/CreateUploadUrls", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &CreateUploadUrlsResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// DeleteBundleByFriendlyId delete a bundle by friendly Id
// https://api.playfab.com/Documentation/Economy/method/DeleteBundleByFriendlyId
func DeleteBundleByFriendlyId(settings *playfab.Settings, postData *DeleteBundleByFriendlyIdRequestModel, entityToken string) (*DeleteBundleResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Catalog/DeleteBundleByFriendlyId", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &DeleteBundleResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// DeleteBundleById delete a bundle by Id
// https://api.playfab.com/Documentation/Economy/method/DeleteBundleById
func DeleteBundleById(settings *playfab.Settings, postData *DeleteBundleByIdRequestModel, entityToken string) (*DeleteBundleResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Catalog/DeleteBundleById", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &DeleteBundleResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// DeleteItem removes an item from working catalog and all published versions from the public catalog.
// https://api.playfab.com/Documentation/Economy/method/DeleteItem
func DeleteItem(settings *playfab.Settings, postData *DeleteItemRequestModel, entityToken string) (*DeleteItemResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Catalog/DeleteItem", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &DeleteItemResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// DeleteStoreByFriendlyId delete a store by friendly Id
// https://api.playfab.com/Documentation/Economy/method/DeleteStoreByFriendlyId
func DeleteStoreByFriendlyId(settings *playfab.Settings, postData *DeleteStoreByFriendlyIdRequestModel, entityToken string) (*DeleteStoreResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Catalog/DeleteStoreByFriendlyId", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &DeleteStoreResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// DeleteStoreById delete a store by Id
// https://api.playfab.com/Documentation/Economy/method/DeleteStoreById
func DeleteStoreById(settings *playfab.Settings, postData *DeleteStoreByIdRequestModel, entityToken string) (*DeleteStoreResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Catalog/DeleteStoreById", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &DeleteStoreResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// DeleteSubscriptionByFriendlyId delete a subscription by friendly Id
// https://api.playfab.com/Documentation/Economy/method/DeleteSubscriptionByFriendlyId
func DeleteSubscriptionByFriendlyId(settings *playfab.Settings, postData *DeleteSubscriptionByFriendlyIdRequestModel, entityToken string) (*DeleteSubscriptionResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Catalog/DeleteSubscriptionByFriendlyId", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &DeleteSubscriptionResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// DeleteSubscriptionById delete a subscription by Id
// https://api.playfab.com/Documentation/Economy/method/DeleteSubscriptionById
func DeleteSubscriptionById(settings *playfab.Settings, postData *DeleteSubscriptionByIdRequestModel, entityToken string) (*DeleteSubscriptionResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Catalog/DeleteSubscriptionById", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &DeleteSubscriptionResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// DeleteUgcItem removes an item from working catalog and all published versions from the public catalog.
// https://api.playfab.com/Documentation/Economy/method/DeleteUgcItem
func DeleteUgcItem(settings *playfab.Settings, postData *DeleteItemRequestModel, entityToken string) (*DeleteItemResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/UserGeneratedContent/DeleteUgcItem", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &DeleteItemResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetBundleByFriendlyId get a bundle by Friendly Id
// https://api.playfab.com/Documentation/Economy/method/GetBundleByFriendlyId
func GetBundleByFriendlyId(settings *playfab.Settings, postData *GetBundleByFriendlyIdRequestModel, entityToken string) (*GetBundleResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Catalog/GetBundleByFriendlyId", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &GetBundleResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetBundleById get a bundle by Id
// https://api.playfab.com/Documentation/Economy/method/GetBundleById
func GetBundleById(settings *playfab.Settings, postData *GetBundleByIdRequestModel, entityToken string) (*GetBundleResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Catalog/GetBundleById", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &GetBundleResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetBundleByMarketplaceOfferId get a bundle by marketplace offer Id
// https://api.playfab.com/Documentation/Economy/method/GetBundleByMarketplaceOfferId
func GetBundleByMarketplaceOfferId(settings *playfab.Settings, postData *GetBundleByMarketplaceOfferIdRequestModel, entityToken string) (*GetBundleResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Catalog/GetBundleByMarketplaceOfferId", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &GetBundleResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetCatalogConfig gets the configuration for the catalog.
// https://api.playfab.com/Documentation/Economy/method/GetCatalogConfig
func GetCatalogConfig(settings *playfab.Settings, postData *GetCatalogConfigRequestModel, entityToken string) (*GetCatalogConfigResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Catalog/GetCatalogConfig", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &GetCatalogConfigResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetCurrencyById retrieve a currency by id
// https://api.playfab.com/Documentation/Economy/method/GetCurrencyById
func GetCurrencyById(settings *playfab.Settings, postData *GetCurrencyByIdRequestModel, entityToken string) (*GetCurrencyByIdResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Catalog/GetCurrencyById", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &GetCurrencyByIdResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetDraftItem retrieves an item from the working catalog. This item represents the current working state of the catalog item.
// https://api.playfab.com/Documentation/Economy/method/GetDraftItem
func GetDraftItem(settings *playfab.Settings, postData *GetDraftItemRequestModel, entityToken string) (*GetDraftItemResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Catalog/GetDraftItem", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &GetDraftItemResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetDraftItems retrieves a paginated list of the items from the draft catalog.
// https://api.playfab.com/Documentation/Economy/method/GetDraftItems
func GetDraftItems(settings *playfab.Settings, postData *GetDraftItemsRequestModel, entityToken string) (*GetDraftItemsResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Catalog/GetDraftItems", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &GetDraftItemsResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetDraftUgcItem retrieves an item from the working catalog. This item represents the current working state of the community item.
// https://api.playfab.com/Documentation/Economy/method/GetDraftUgcItem
func GetDraftUgcItem(settings *playfab.Settings, postData *GetDraftItemRequestModel, entityToken string) (*GetDraftItemResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/UserGeneratedContent/GetDraftUgcItem", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &GetDraftItemResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetDraftUgcItems retrieves a paginated list of the items created by a user.
// https://api.playfab.com/Documentation/Economy/method/GetDraftUgcItems
func GetDraftUgcItems(settings *playfab.Settings, postData *GetDraftItemsRequestModel, entityToken string) (*GetDraftItemsResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/UserGeneratedContent/GetDraftUgcItems", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &GetDraftItemsResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetInventoryItems get current inventory items.
// https://api.playfab.com/Documentation/Economy/method/GetInventoryItems
func GetInventoryItems(settings *playfab.Settings, postData *GetInventoryItemsRequestModel, entityToken string) (*GetInventoryItemsResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Inventory/GetInventoryItems", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &GetInventoryItemsResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetItemReviews get a paginated set of reviews associated with the specified item.
// https://api.playfab.com/Documentation/Economy/method/GetItemReviews
func GetItemReviews(settings *playfab.Settings, postData *GetReviewsRequestModel, entityToken string) (*GetReviewsResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Catalog/GetItemReviews", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &GetReviewsResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetItemReviewSummary get a summary of all reviews associated with the specified item.
// https://api.playfab.com/Documentation/Economy/method/GetItemReviewSummary
func GetItemReviewSummary(settings *playfab.Settings, postData *ReviewSummaryRequestModel, entityToken string) (*ReviewSummaryResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Catalog/GetItemReviewSummary", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &ReviewSummaryResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetMyReview gets the submitted review for the specifed item by the authenticated user.
// https://api.playfab.com/Documentation/Economy/method/GetMyReview
func GetMyReview(settings *playfab.Settings, postData *GetMyReviewRequestModel, entityToken string) (*GetMyReviewResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Catalog/GetMyReview", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &GetMyReviewResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetPublishedItem retrieves an item from the public catalog.
// https://api.playfab.com/Documentation/Economy/method/GetPublishedItem
func GetPublishedItem(settings *playfab.Settings, postData *GetPublishedItemRequestModel, entityToken string) (*GetPublishedItemResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Catalog/GetPublishedItem", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &GetPublishedItemResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetPublishedUgcItem retrieves an item from the public catalog.
// https://api.playfab.com/Documentation/Economy/method/GetPublishedUgcItem
func GetPublishedUgcItem(settings *playfab.Settings, postData *GetPublishedItemRequestModel, entityToken string) (*GetPublishedItemResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/UserGeneratedContent/GetPublishedUgcItem", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &GetPublishedItemResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetPublishStatus gets the status of a publish of an item.
// https://api.playfab.com/Documentation/Economy/method/GetPublishStatus
func GetPublishStatus(settings *playfab.Settings, postData *PublishStatusRequestModel, entityToken string) (*PublishStatusResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Catalog/GetPublishStatus", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &PublishStatusResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetStoreByFriendlyId get a store by Friendly Id
// https://api.playfab.com/Documentation/Economy/method/GetStoreByFriendlyId
func GetStoreByFriendlyId(settings *playfab.Settings, postData *GetStoreByFriendlyIdRequestModel, entityToken string) (*GetStoreResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Catalog/GetStoreByFriendlyId", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &GetStoreResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetStoreById get a store by Id
// https://api.playfab.com/Documentation/Economy/method/GetStoreById
func GetStoreById(settings *playfab.Settings, postData *GetStoreByIdRequestModel, entityToken string) (*GetStoreResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Catalog/GetStoreById", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &GetStoreResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetSubscriptionByFriendlyId get a subscription by Friendly Id
// https://api.playfab.com/Documentation/Economy/method/GetSubscriptionByFriendlyId
func GetSubscriptionByFriendlyId(settings *playfab.Settings, postData *GetSubscriptionByFriendlyIdRequestModel, entityToken string) (*GetSubscriptionResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Catalog/GetSubscriptionByFriendlyId", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &GetSubscriptionResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetSubscriptionById get a subscription by Id
// https://api.playfab.com/Documentation/Economy/method/GetSubscriptionById
func GetSubscriptionById(settings *playfab.Settings, postData *GetSubscriptionByIdRequestModel, entityToken string) (*GetSubscriptionResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Catalog/GetSubscriptionById", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &GetSubscriptionResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetSubscriptionByMarketplaceOfferId get a subscription by marketplace offer Id
// https://api.playfab.com/Documentation/Economy/method/GetSubscriptionByMarketplaceOfferId
func GetSubscriptionByMarketplaceOfferId(settings *playfab.Settings, postData *GetSubscriptionByMarketplaceOfferIdRequestModel, entityToken string) (*GetSubscriptionResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Catalog/GetSubscriptionByMarketplaceOfferId", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &GetSubscriptionResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetUgcItemModerationState gets the moderation state for an item, including the concern category and string reason.
// https://api.playfab.com/Documentation/Economy/method/GetUgcItemModerationState
func GetUgcItemModerationState(settings *playfab.Settings, postData *GetUgcItemModerationStateRequestModel, entityToken string) (*GetUgcItemModerationStateResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/UserGeneratedContent/GetUgcItemModerationState", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &GetUgcItemModerationStateResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetUgcPublishStatus gets the status of a publish of an item.
// https://api.playfab.com/Documentation/Economy/method/GetUgcPublishStatus
func GetUgcPublishStatus(settings *playfab.Settings, postData *PublishStatusRequestModel, entityToken string) (*PublishStatusResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/UserGeneratedContent/GetUgcPublishStatus", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &PublishStatusResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GetVirtualCurrencies get current virtual currencies.
// https://api.playfab.com/Documentation/Economy/method/GetVirtualCurrencies
func GetVirtualCurrencies(settings *playfab.Settings, postData *GetVirtualCurrenciesRequestModel, entityToken string) (*GetVirtualCurrenciesResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Inventory/GetVirtualCurrencies", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &GetVirtualCurrenciesResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// GrantInventoryItems grant inventory items.
// https://api.playfab.com/Documentation/Economy/method/GrantInventoryItems
func GrantInventoryItems(settings *playfab.Settings, postData *GrantInventoryItemsRequestModel, entityToken string) (*GrantInventoryItemsResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Inventory/GrantInventoryItems", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &GrantInventoryItemsResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// PublishItem initiates a publish of an item from the working catalog to the public catalog.
// https://api.playfab.com/Documentation/Economy/method/PublishItem
func PublishItem(settings *playfab.Settings, postData *PublishItemRequestModel, entityToken string) (*PublishItemResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Catalog/PublishItem", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &PublishItemResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// PublishUgcItem initiates a publish of a item from the working catalog to the public catalog.
// https://api.playfab.com/Documentation/Economy/method/PublishUgcItem
func PublishUgcItem(settings *playfab.Settings, postData *PublishItemRequestModel, entityToken string) (*PublishItemResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/UserGeneratedContent/PublishUgcItem", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &PublishItemResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// PurchaseItemByFriendlyId purchase an item, bundle or subscription by friendly id.
// https://api.playfab.com/Documentation/Economy/method/PurchaseItemByFriendlyId
func PurchaseItemByFriendlyId(settings *playfab.Settings, postData *PurchaseItemByFriendlyIdRequestModel, entityToken string) (*PurchaseItemResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Catalog/PurchaseItemByFriendlyId", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &PurchaseItemResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// PurchaseItemById purchase an item, bundle or subscription by id.
// https://api.playfab.com/Documentation/Economy/method/PurchaseItemById
func PurchaseItemById(settings *playfab.Settings, postData *PurchaseItemByIdRequestModel, entityToken string) (*PurchaseItemResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Catalog/PurchaseItemById", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &PurchaseItemResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// ReportReview submit a report for a review
// https://api.playfab.com/Documentation/Economy/method/ReportReview
func ReportReview(settings *playfab.Settings, postData *ReportReviewRequestModel, entityToken string) (*ReportReviewResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Catalog/ReportReview", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &ReportReviewResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// ReportUgcItem submit a report for an item, indicating in what way the item is inappropriate.
// https://api.playfab.com/Documentation/Economy/method/ReportUgcItem
func ReportUgcItem(settings *playfab.Settings, postData *ReportItemRequestModel, entityToken string) (*ReportItemResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/UserGeneratedContent/ReportUgcItem", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &ReportItemResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// Search execute a search against the public catalog using the provided search parameters and returns a set of paginated results.
// https://api.playfab.com/Documentation/Economy/method/Search
func Search(settings *playfab.Settings, postData *CatalogSearchRequestModel, entityToken string) (*CatalogSearchResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Catalog/Search", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &CatalogSearchResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// SearchBundles execute a search against the set of all bundles, using the provided search parameters and returns a set of paginated
// results
// https://api.playfab.com/Documentation/Economy/method/SearchBundles
func SearchBundles(settings *playfab.Settings, postData *SearchBundlesRequestModel, entityToken string) (*SearchBundlesResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Catalog/SearchBundles", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &SearchBundlesResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// SearchForItemsContainingItemByFriendlyId search for a given item (by friendly id) and return a set of bundles/subscriptions/stores containing the item
// https://api.playfab.com/Documentation/Economy/method/SearchForItemsContainingItemByFriendlyId
func SearchForItemsContainingItemByFriendlyId(settings *playfab.Settings, postData *SearchForItemsContainingItemByFriendlyIdRequestModel, entityToken string) (*SearchForItemsContainingItemResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Catalog/SearchForItemsContainingItemByFriendlyId", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &SearchForItemsContainingItemResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// SearchForItemsContainingItemById search for a given item (by id) and return a set of bundles/subscriptions/stores containing the item
// https://api.playfab.com/Documentation/Economy/method/SearchForItemsContainingItemById
func SearchForItemsContainingItemById(settings *playfab.Settings, postData *SearchForItemsContainingItemByIdRequestModel, entityToken string) (*SearchForItemsContainingItemResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Catalog/SearchForItemsContainingItemById", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &SearchForItemsContainingItemResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// SearchInStoreByFriendlyId execute a search against a specified store (by friendly id) using the provided search parameters and return a set of
// paginated results
// https://api.playfab.com/Documentation/Economy/method/SearchInStoreByFriendlyId
func SearchInStoreByFriendlyId(settings *playfab.Settings, postData *SearchInStoreByFriendlyIdRequestModel, entityToken string) (*SearchInStoreResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Catalog/SearchInStoreByFriendlyId", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &SearchInStoreResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// SearchInStoreById execute a search against a specified store (by id) using the provided search parameters and return a set of paginated
// results
// https://api.playfab.com/Documentation/Economy/method/SearchInStoreById
func SearchInStoreById(settings *playfab.Settings, postData *SearchInStoreByIdRequestModel, entityToken string) (*SearchInStoreResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Catalog/SearchInStoreById", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &SearchInStoreResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// SearchStores execute a search against the set of all stores, using the provided search parameters and returns a set of paginated
// results
// https://api.playfab.com/Documentation/Economy/method/SearchStores
func SearchStores(settings *playfab.Settings, postData *SearchStoresRequestModel, entityToken string) (*SearchStoresResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Catalog/SearchStores", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &SearchStoresResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// SearchSubscriptions execute a search against the set of all subscriptions, using the provided search parameters and returns a set of
// paginated results
// https://api.playfab.com/Documentation/Economy/method/SearchSubscriptions
func SearchSubscriptions(settings *playfab.Settings, postData *SearchSubscriptionsRequestModel, entityToken string) (*SearchSubscriptionsResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Catalog/SearchSubscriptions", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &SearchSubscriptionsResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// SetInventoryItems set inventory items
// https://api.playfab.com/Documentation/Economy/method/SetInventoryItems
func SetInventoryItems(settings *playfab.Settings, postData *SetInventoryItemsRequestModel, entityToken string) (*SetInventoryItemsResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Inventory/SetInventoryItems", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &SetInventoryItemsResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// SetUgcItemModerationState sets the moderation state for an item, including the concern category and string reason.
// https://api.playfab.com/Documentation/Economy/method/SetUgcItemModerationState
func SetUgcItemModerationState(settings *playfab.Settings, postData *SetUgcItemModerationStateRequestModel, entityToken string) (*SetUgcItemModerationStateResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/UserGeneratedContent/SetUgcItemModerationState", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &SetUgcItemModerationStateResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// SetVirtualCurrencies set virtual currencies
// https://api.playfab.com/Documentation/Economy/method/SetVirtualCurrencies
func SetVirtualCurrencies(settings *playfab.Settings, postData *SetVirtualCurrenciesRequestModel, entityToken string) (*SetVirtualCurrenciesResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Inventory/SetVirtualCurrencies", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &SetVirtualCurrenciesResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// SubmitHelpfulnessVote submit a vote for a review, indicating whether the review was helpful or unhelpful.
// https://api.playfab.com/Documentation/Economy/method/SubmitHelpfulnessVote
func SubmitHelpfulnessVote(settings *playfab.Settings, postData *HelpfulnessVoteRequestModel, entityToken string) (*HelpfulnessVoteResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Catalog/SubmitHelpfulnessVote", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &HelpfulnessVoteResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// SubtractVirtualCurrencies decrease virtual currencies amount.
// https://api.playfab.com/Documentation/Economy/method/SubtractVirtualCurrencies
func SubtractVirtualCurrencies(settings *playfab.Settings, postData *SubtractVirtualCurrenciesRequestModel, entityToken string) (*SubtractVirtualCurrenciesResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Inventory/SubtractVirtualCurrencies", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &SubtractVirtualCurrenciesResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// TakedownReviews submit a request to takedown one or more reviews.
// https://api.playfab.com/Documentation/Economy/method/TakedownReviews
func TakedownReviews(settings *playfab.Settings, postData *TakedownReviewsRequestModel, entityToken string) (*TakedownReviewsResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Catalog/TakedownReviews", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &TakedownReviewsResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// UpdateBundle update a bundle
// https://api.playfab.com/Documentation/Economy/method/UpdateBundle
func UpdateBundle(settings *playfab.Settings, postData *UpdateBundleRequestModel, entityToken string) (*UpdateBundleResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Catalog/UpdateBundle", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &UpdateBundleResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// UpdateCatalogConfig gets the configuration for the catalog.
// https://api.playfab.com/Documentation/Economy/method/UpdateCatalogConfig
func UpdateCatalogConfig(settings *playfab.Settings, postData *UpdateCatalogConfigRequestModel, entityToken string) (*UpdateCatalogConfigResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Catalog/UpdateCatalogConfig", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &UpdateCatalogConfigResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// UpdateCurrency update a currency
// https://api.playfab.com/Documentation/Economy/method/UpdateCurrency
func UpdateCurrency(settings *playfab.Settings, postData *UpdateCurrencyRequestModel, entityToken string) (*UpdateCurrencyResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Catalog/UpdateCurrency", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &UpdateCurrencyResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// UpdateDraftItem update the metadata for an item in the working catalog.
// https://api.playfab.com/Documentation/Economy/method/UpdateDraftItem
func UpdateDraftItem(settings *playfab.Settings, postData *UpdateDraftItemRequestModel, entityToken string) (*UpdateDraftItemResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Catalog/UpdateDraftItem", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &UpdateDraftItemResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// UpdateDraftUgcItem update the metadata for an item in the working catalog.
// https://api.playfab.com/Documentation/Economy/method/UpdateDraftUgcItem
func UpdateDraftUgcItem(settings *playfab.Settings, postData *UpdateDraftItemRequestModel, entityToken string) (*UpdateDraftItemResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/UserGeneratedContent/UpdateDraftUgcItem", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &UpdateDraftItemResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// UpdateInventoryItemsProperties update inventory Items.
// https://api.playfab.com/Documentation/Economy/method/UpdateInventoryItemsProperties
func UpdateInventoryItemsProperties(settings *playfab.Settings, postData *UpdateInventoryItemsPropertiesRequestModel, entityToken string) (*UpdateInventoryPropertiesItemsResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Inventory/UpdateInventoryItemsProperties", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &UpdateInventoryPropertiesItemsResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// UpdateStore update a store
// https://api.playfab.com/Documentation/Economy/method/UpdateStore
func UpdateStore(settings *playfab.Settings, postData *UpdateStoreRequestModel, entityToken string) (*UpdateStoreResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Catalog/UpdateStore", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &UpdateStoreResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}

// UpdateSubscription update a subscription
// https://api.playfab.com/Documentation/Economy/method/UpdateSubscription
func UpdateSubscription(settings *playfab.Settings, postData *UpdateSubscriptionRequestModel, entityToken string) (*UpdateSubscriptionResultModel, error) {
    if entityToken == "" {
        return nil, playfab.NewCustomError("entityToken should not be an empty string", playfab.ErrorGeneric)
    }
    b, errMarshal := json.Marshal(postData)
    if errMarshal != nil {
        return nil, playfab.NewCustomError(errMarshal.Error(), playfab.ErrorMarshal)
    }

    sourceMap, err := playfab.Request(settings, b, "/Catalog/UpdateSubscription", "X-EntityToken", entityToken)
    if err != nil {
        return nil, err
    }
    
    result := &UpdateSubscriptionResultModel{}

    config := mapstructure.DecoderConfig{
        DecodeHook: playfab.StringToDateTimeHook,
        Result:     result,
    }
    
    decoder, errDecoding := mapstructure.NewDecoder(&config)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }
   
    errDecoding = decoder.Decode(sourceMap)
    if errDecoding != nil {
        return nil, playfab.NewCustomError(errDecoding.Error(), playfab.ErrorDecoding)
    }

    return result, nil
}



